"""
Enhanced Chatbot with Greeting Cooldown and Fallback Mode
X·ª≠ l√Ω chatbot v·ªõi gi·ªõi h·∫°n ch√†o l·∫°i v√† ch·∫ø ƒë·ªô d·ª± ph√≤ng
"""

import google.generativeai as genai
import os
from dotenv import load_dotenv
import json
from datetime import datetime, timedelta
import time
from typing import Dict, Optional
import tempfile
from gtts import gTTS
import io
import pygame

# Load environment variables
load_dotenv()

class GreetingManager:
    """Qu·∫£n l√Ω vi·ªác ch√†o h·ªèi v·ªõi cooldown 5 ph√∫t"""
    
    def __init__(self, cooldown_minutes: int = 5):
        self.cooldown_minutes = cooldown_minutes
        self.last_greetings: Dict[str, datetime] = {}  # {person_name: last_greeting_time}
    
    def should_greet(self, person_name: str) -> bool:
        """
        Ki·ªÉm tra c√≥ n√™n ch√†o ng∆∞·ªùi n√†y kh√¥ng (d·ª±a tr√™n cooldown)
        
        Args:
            person_name: T√™n ng∆∞·ªùi ƒë∆∞·ª£c nh·∫≠n di·ªán
            
        Returns:
            True n·∫øu n√™n ch√†o, False n·∫øu ch∆∞a ƒë·ªß 5 ph√∫t
        """
        if not person_name or person_name in ["Unknown", "Error"]:
            return False
            
        now = datetime.now()
        
        # N·∫øu ch∆∞a t·ª´ng ch√†o person n√†y
        if person_name not in self.last_greetings:
            self.last_greetings[person_name] = now
            return True
        
        # Ki·ªÉm tra th·ªùi gian t·ª´ l·∫ßn ch√†o cu·ªëi
        last_greeting = self.last_greetings[person_name]
        time_diff = now - last_greeting
        
        # N·∫øu ƒë√£ qu√° 5 ph√∫t
        if time_diff >= timedelta(minutes=self.cooldown_minutes):
            self.last_greetings[person_name] = now
            return True
        
        return False
    
    def get_time_until_next_greeting(self, person_name: str) -> Optional[int]:
        """
        L·∫•y s·ªë gi√¢y c√≤n l·∫°i cho ƒë·∫øn khi c√≥ th·ªÉ ch√†o l·∫°i
        
        Returns:
            S·ªë gi√¢y c√≤n l·∫°i, ho·∫∑c None n·∫øu c√≥ th·ªÉ ch√†o ngay
        """
        if person_name not in self.last_greetings:
            return None
            
        now = datetime.now()
        last_greeting = self.last_greetings[person_name]
        cooldown_end = last_greeting + timedelta(minutes=self.cooldown_minutes)
        
        if now >= cooldown_end:
            return None
        
        return int((cooldown_end - now).total_seconds())


class TTSHandler:
    """X·ª≠ l√Ω Text-to-Speech v·ªõi gTTS ƒë∆°n gi·∫£n"""

    def __init__(self):
        try:
            pygame.mixer.init()
            self.available = True
            print("‚úÖ TTS Handler initialized successfully")
        except Exception as e:
            print(f"‚ö†Ô∏è TTS Handler initialization failed: {e}")
            self.available = False

    def speak_text(self, text: str, lang: str = 'vi') -> bool:
        """
        Ph√°t √¢m vƒÉn b·∫£n s·ª≠ d·ª•ng gTTS
        
        Args:
            text: VƒÉn b·∫£n c·∫ßn ph√°t √¢m
            lang: Ng√¥n ng·ªØ (m·∫∑c ƒë·ªãnh 'vi' cho ti·∫øng Vi·ªát)
            
        Returns:
            True n·∫øu th√†nh c√¥ng, False n·∫øu l·ªói
        """
        if not self.available or not text.strip():
            return False
            
        try:
            # T·∫°o file √¢m thanh t·∫°m th·ªùi
            tts = gTTS(text=text, lang=lang, slow=False)
            
            # S·ª≠ d·ª•ng tempfile ƒë·ªÉ t·∫°o file t·∫°m an to√†n h∆°n
            import tempfile
            temp_dir = tempfile.gettempdir()
            temp_filename = f"tts_{int(time.time())}.mp3"
            temp_path = os.path.join(temp_dir, temp_filename)
            
            try:
                # L∆∞u file √¢m thanh
                tts.save(temp_path)
                
                # ƒê·ª£i file ƒë∆∞·ª£c t·∫°o ho√†n ch·ªânh
                time.sleep(0.1)
                
                # Ki·ªÉm tra file t·ªìn t·∫°i
                if not os.path.exists(temp_path):
                    print(f"‚ùå TTS file not created: {temp_path}")
                    return False
                
                # Ph√°t √¢m thanh
                pygame.mixer.music.load(temp_path)
                pygame.mixer.music.play()
                
                # ƒê·ª£i ph√°t xong
                while pygame.mixer.music.get_busy():
                    pygame.time.wait(100)
                
                return True
                
            finally:
                # Cleanup - x√≥a file t·∫°m
                try:
                    if os.path.exists(temp_path):
                        os.unlink(temp_path)
                except:
                    pass  # Ignore cleanup errors
                
        except Exception as e:
            print(f"‚ùå TTS Error: {e}")
            return False


class EnhancedChatBot:
    """Chatbot c·∫£i ti·∫øn v·ªõi fallback mode v√† x·ª≠ l√Ω l·ªói t·ªët h∆°n"""
    
    def __init__(self, model: str = "gemini-1.5-flash"):
        self.model_name = model
        self.conversation_history = []
        self.context_data = {}
        self.greeting_manager = GreetingManager(cooldown_minutes=5)
        self.fallback_mode = False
        
        # C·∫•u h√¨nh Gemini API
        self._initialize_gemini()
        
        self.enhanced_system_prompt = """
B·∫°n l√† m·ªôt tr·ª£ l√Ω AI th√¥ng minh, th√¢n thi·ªán v√† nghi√™m t√∫c. ƒê·∫∑c ƒëi·ªÉm c·ªßa b·∫°n:

üéØ T√çNH C√ÅCH:
- Nghi√™m t√∫c, c·ªüi m·ªü

üí≠ C√ÅCH TR·∫ÆC ƒê√ÅP:
- Lu√¥n tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát t·ª± nhi√™n
- Ch·ªâ tr·∫£ l·ªùi ng·∫Øn g·ªçn 1-2 c√¢u
- Tr·∫£ l·ªùi ng·∫Øn g·ªçn nh·ªØng th√¥ng tin c·∫ßn thi·∫øt



üî• QUAN TR·ªåNG: B·∫°n lu√¥n c√≥ th·ªÉ tr√≤ chuy·ªán v·ªõi b·∫•t k·ª≥ ai, b·∫•t c·ª© l√∫c n√†o! Kh√¥ng c√≥ gi·ªõi h·∫°n th·ªùi gian hay cooldown cho vi·ªác chat!

H√£y b·∫Øt ƒë·∫ßu cu·ªôc tr√≤ chuy·ªán m·ªôt c√°ch t·ª± nhi√™n v√† th√¢n thi·ªán!
        """

    def _initialize_gemini(self):
        """Kh·ªüi t·∫°o Gemini API v·ªõi x·ª≠ l√Ω l·ªói"""
        try:
            api_key = os.getenv('GEMINI_API_KEY')
            if not api_key or api_key == 'your_gemini_api_key_here':
                print("‚ö†Ô∏è GEMINI_API_KEY not found or not set properly. Using fallback mode.")
                self.fallback_mode = True
                return
            
            genai.configure(api_key=api_key)
            
            # Test connection
            self.model = genai.GenerativeModel(
                model_name=self.model_name,
                generation_config={
                    "temperature": 0.7,
                    "top_p": 0.8,
                    "top_k": 40,
                    "max_output_tokens": 2048,
                }
            )
            
            # Test v·ªõi m·ªôt c√¢u h·ªèi ƒë∆°n gi·∫£n
            test_response = self.model.generate_content("Hello")
            if test_response and test_response.text:
                print("‚úÖ Gemini API connected successfully")
                self.fallback_mode = False
            else:
                raise Exception("Invalid response from Gemini API")
                
        except Exception as e:
            print(f"‚ö†Ô∏è Gemini API initialization failed: {e}")
            print("üîÑ Switching to fallback mode")
            self.fallback_mode = True
            self.model = None

    def add_context(self, key: str, value: str):
        """Th√™m th√¥ng tin ng·ªØ c·∫£nh"""
        self.context_data[key] = value

    def get_auto_greeting(self, person_name: str, person_info: Dict = None) -> Optional[str]:
        """
        T·∫°o l·ªùi ch√†o t·ª± ƒë·ªông khi nh·∫≠n di·ªán khu√¥n m·∫∑t (v·ªõi cooldown 5 ph√∫t)
        Ch·ªâ d√†nh cho auto-greeting, kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn chat th∆∞·ªùng
        
        Args:
            person_name: T√™n ng∆∞·ªùi ƒë∆∞·ª£c nh·∫≠n di·ªán
            person_info: Th√¥ng tin chi ti·∫øt v·ªÅ ng∆∞·ªùi ƒë√≥
            
        Returns:
            L·ªùi ch√†o n·∫øu n√™n ch√†o, None n·∫øu kh√¥ng n√™n ch√†o (ch∆∞a ƒë·ªß 5 ph√∫t)
        """
        # Ki·ªÉm tra c√≥ n√™n ch√†o kh√¥ng (ch·ªâ √°p d·ª•ng cho auto-greeting)
        if not self.greeting_manager.should_greet(person_name):
            remaining_seconds = self.greeting_manager.get_time_until_next_greeting(person_name)
            if remaining_seconds:
                remaining_minutes = remaining_seconds // 60
                print(f"‚è∞ Auto-greeting cooldown for {person_name}. Next greeting in {remaining_minutes}:{remaining_seconds%60:02d}")
            return None
        
        # T·∫°o l·ªùi ch√†o t·ª± ƒë·ªông
        current_hour = datetime.now().hour
        
        # Ch√†o theo th·ªùi gian
        if 5 <= current_hour < 12:
            time_greeting = "Ch√†o bu·ªïi s√°ng"
        elif 12 <= current_hour < 18:
            time_greeting = "Ch√†o bu·ªïi chi·ªÅu"
        else:
            time_greeting = "Ch√†o bu·ªïi t·ªëi"
        
        # Th√™m th√¥ng tin c√° nh√¢n n·∫øu c√≥
        personal_info = ""
        if person_info:
            if person_info.get('position_applied'):
                personal_info = f" H√¥m nay b·∫°n ƒë·∫øn ph·ªèng v·∫•n v·ªã tr√≠ {person_info['position_applied']} ph·∫£i kh√¥ng?"
            elif person_info.get('major'):
                personal_info = f" R·∫•t vui ƒë∆∞·ª£c g·∫∑p b·∫°n!"
        
        greeting = f"{time_greeting} {person_name}!{personal_info} T√¥i l√† Donkey, tr·ª£ l√Ω AI ·ªü ƒë√¢y. B·∫°n c·∫ßn h·ªó tr·ª£ g√¨ kh√¥ng?"
        
        print(f"üëã Auto-greeting generated for {person_name}")
        return greeting

    def get_greeting_message(self, person_name: str, person_info: Dict = None) -> Optional[str]:
        """
        Backward compatibility - chuy·ªÉn h∆∞·ªõng ƒë·∫øn get_auto_greeting
        """
        return self.get_auto_greeting(person_name, person_info)

    def get_response(self, user_message: str, person_name: str = "") -> str:
        """
        L·∫•y ph·∫£n h·ªìi t·ª´ chatbot
        
        Args:
            user_message: Tin nh·∫Øn t·ª´ ng∆∞·ªùi d√πng
            person_name: T√™n ng∆∞·ªùi ƒëang tr√≤ chuy·ªán (n·∫øu c√≥)
            
        Returns:
            Ph·∫£n h·ªìi t·ª´ chatbot
        """
        if not user_message.strip():
            return "B·∫°n c√≥ mu·ªën n√≥i g√¨ v·ªõi t√¥i kh√¥ng? üòä"
        
        # N·∫øu trong ch·∫ø ƒë·ªô fallback
        if self.fallback_mode:
            return self._get_fallback_response(user_message, person_name)
        
        try:
            # Th√™m ng·ªØ c·∫£nh n·∫øu c√≥ t√™n ng∆∞·ªùi
            context = ""
            if person_name:
                context = f"T√™n ng∆∞·ªùi ƒëang tr√≤ chuy·ªán: {person_name}\n"
                if self.context_data:
                    context += "Th√¥ng tin b·ªï sung:\n"
                    for key, value in self.context_data.items():
                        context += f"- {key}: {value}\n"
            
            # T·∫°o prompt v·ªõi ng·ªØ c·∫£nh
            full_prompt = f"{self.enhanced_system_prompt}\n\n{context}\nNg∆∞·ªùi d√πng: {user_message}"
            
            # G·ªçi Gemini API
            response = self.model.generate_content(full_prompt)
            
            if response and response.text:
                return response.text.strip()
            else:
                return self._get_fallback_response(user_message, person_name)
                
        except Exception as e:
            print(f"‚ùå Gemini API Error: {e}")
            return self._get_fallback_response(user_message, person_name)

    def _get_fallback_response(self, user_message: str, person_name: str = "") -> str:
        """Ph·∫£n h·ªìi d·ª± ph√≤ng khi Gemini API kh√¥ng kh·∫£ d·ª•ng"""
        
        # Ph·∫£n h·ªìi theo t·ª´ kh√≥a
        message_lower = user_message.lower()
        
        # Ch√†o h·ªèi
        if any(word in message_lower for word in ["xin ch√†o", "ch√†o", "hello", "hi"]):
            if person_name:
                return f"Xin ch√†o {person_name}! T√¥i l√† Donkey, tr·ª£ l√Ω AI. T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n? üòä"
            return "Xin ch√†o! T√¥i l√† Donkey, tr·ª£ l√Ω AI. R·∫•t vui ƒë∆∞·ª£c g·∫∑p b·∫°n! üëã"
        
        # H·ªèi v·ªÅ t√™n
        elif any(word in message_lower for word in ["t√™n", "b·∫°n l√† ai", "ai"]):
            return "T√¥i l√† Donkey, tr·ª£ l√Ω AI th√¥ng minh v√† th√¢n thi·ªán! ƒê∆∞·ª£c t·∫°o ra ƒë·ªÉ h·ªó tr·ª£ b·∫°n. ü§ñ"
        
        # H·ªèi v·ªÅ th·ªùi gian
        elif any(word in message_lower for word in ["gi·ªù", "th·ªùi gian", "b√¢y gi·ªù"]):
            now = datetime.now()
            return f"B√¢y gi·ªù l√† {now.strftime('%H:%M')} ng√†y {now.strftime('%d/%m/%Y')} ‚è∞"
        
        # C·∫£m ∆°n
        elif any(word in message_lower for word in ["c·∫£m ∆°n", "c√°m ∆°n", "thank"]):
            return "Kh√¥ng c√≥ g√¨! R·∫•t vui ƒë∆∞·ª£c gi√∫p ƒë·ª° b·∫°n üòä"
        
        # T·∫°m bi·ªát
        elif any(word in message_lower for word in ["t·∫°m bi·ªát", "bye", "goodbye"]):
            if person_name:
                return f"T·∫°m bi·ªát {person_name}! Ch√∫c b·∫°n m·ªôt ng√†y t·ªët l√†nh! üëã"
            return "T·∫°m bi·ªát! H·∫πn g·∫∑p l·∫°i b·∫°n sau! üëã"
        
        # Ph·ªèng v·∫•n
        elif any(word in message_lower for word in ["ph·ªèng v·∫•n", "interview", "l·ªãch h·∫πn"]):
            return "T√¥i c√≥ th·ªÉ gi√∫p b·∫°n tra c·ª©u th√¥ng tin l·ªãch ph·ªèng v·∫•n. B·∫°n c·∫ßn h·ªó tr·ª£ g√¨ c·ª• th·ªÉ? üìÖ"
        
        # M·∫∑c ƒë·ªãnh
        else:
            responses = [
                "T√¥i hi·ªÉu √Ω b·∫°n r·ªìi! Hi·ªán t·∫°i h·ªá th·ªëng AI ƒëang trong ch·∫ø ƒë·ªô ƒë∆°n gi·∫£n. B·∫°n c√≥ th·ªÉ h·ªèi t√¥i v·ªÅ th·ªùi gian, l·ªãch ph·ªèng v·∫•n ho·∫∑c th√¥ng tin c∆° b·∫£n kh√°c! üòä",
                "ƒê√≥ l√† m·ªôt c√¢u h·ªèi hay! Tuy nhi√™n h·ªá th·ªëng AI ƒëang ho·∫°t ƒë·ªông ·ªü ch·∫ø ƒë·ªô c∆° b·∫£n. T√¥i c√≥ th·ªÉ gi√∫p b·∫°n v·ªõi nh·ªØng th√¥ng tin ƒë∆°n gi·∫£n! ü§ñ",
                "C·∫£m ∆°n b·∫°n ƒë√£ chia s·∫ª! Hi·ªán t·∫°i t√¥i ƒëang ho·∫°t ƒë·ªông v·ªõi nh·ªØng t√≠nh nƒÉng c∆° b·∫£n. B·∫°n c·∫ßn h·ªó tr·ª£ g√¨ kh√°c kh√¥ng? ‚ú®"
            ]
            
            # Ch·ªçn ph·∫£n h·ªìi d·ª±a tr√™n th·ªùi gian ƒë·ªÉ c√≥ t√≠nh ng·∫´u nhi√™n
            import time
            response_index = int(time.time()) % len(responses)
            return responses[response_index]

    def get_system_status(self) -> Dict:
        """L·∫•y tr·∫°ng th√°i h·ªá th·ªëng chatbot"""
        return {
            "api_available": not self.fallback_mode,
            "model": self.model_name if not self.fallback_mode else "Fallback Mode",
            "greeting_cooldown_minutes": self.greeting_manager.cooldown_minutes,
            "active_conversations": len(self.greeting_manager.last_greetings),
            "last_greetings": {
                name: time.strftime("%H:%M:%S", time.strptime(str(greeting_time), "%Y-%m-%d %H:%M:%S.%f"))
                for name, greeting_time in self.greeting_manager.last_greetings.items()
            } if self.greeting_manager.last_greetings else {}
        }

# Test function
def test_chatbot():
    """Test chatbot functionality"""
    print("üß™ Testing Enhanced Chatbot...")
    
    try:
        chatbot = EnhancedChatBot()
        tts = TTSHandler()
        
        # Test system status
        status = chatbot.get_system_status()
        print(f"üìä System Status: {status}")
        
        # Test greeting with cooldown
        print("\nüëã Testing greeting cooldown...")
        greeting1 = chatbot.get_greeting_message("Test User", {"position_applied": "Developer"})
        print(f"First greeting: {greeting1}")
        
        greeting2 = chatbot.get_greeting_message("Test User")
        print(f"Second greeting (should be None): {greeting2}")
        
        # Test conversation
        print("\nüí¨ Testing conversation...")
        response = chatbot.get_response("Xin ch√†o!", "Test User")
        print(f"Response: {response}")
        
        # Test TTS if available
        if tts.available:
            print("\nüîä Testing TTS...")
            tts.speak_text("Xin ch√†o! T√¥i l√† Donkey, tr·ª£ l√Ω AI.")
        
        print("\n‚úÖ Chatbot test completed!")
        
    except Exception as e:
        print(f"‚ùå Test failed: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    test_chatbot()